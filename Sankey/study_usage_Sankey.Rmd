---
title: "study_usage_Sankey"
output: html_document
date: "2023-06-02"
---

Document for making Sankey Plot.

On the left side of the plot, we need to have the primary sources
On the right, we need to put how they are used in systematic reviews.


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

```{r}
study_usage <- read.table("study_update.txt", sep="\t", header = T,
                          encoding = "latin1")
head(study_usage)
```

```{r}
# if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
# if (!requireNamespace("ggsankey", quietly = TRUE))  install.packages("ggsankey")
# library("ggsankey")
```


```{r}
if (!requireNamespace("BiocManager", quietly = TRUE)) install.packages("BiocManager")
if (!requireNamespace("networkD3", quietly = TRUE))  BiocManager::install("networkD3")
# Load package
library(networkD3)
# Load energy projection data
URL <- paste0(
        "https://cdn.rawgit.com/christophergandrud/networkD3/",
        "master/JSONdata/energy.json")
Energy <- jsonlite::fromJSON(URL)
# Plot
sankeyNetwork(Links = Energy$links, Nodes = Energy$nodes, Source = "source",
             Target = "target", Value = "value", NodeID = "name",
             units = "TWh", fontSize = 12, nodeWidth = 30)
```

#Plan:
Need to programatically tease out node names c("RCT",Cross-sectional","Cohort", "MA", "T").
Need to find programatically linkages.
  Source and target
Need to make counts (values) for thickness of linkages.

#Psudo-code to find linkages and counts
links <- dataframe for links with headers as: source, target, count
For row in study_usage, if study_usage$Study.Design is present:
  used <- FALSE #flag for determining secondary usage
  source_node_number <- index in all node names
  for column in secondary columns:
    if row in column has name in node_names:
      used <- TRUE
      target_node_number <- index in all node names
      if source_node_number and target_node_number combo in linkds df:
        links[source == source_node_number & target == target_node_number, counts] += 1
      else:
        links[source == source_node_number & target == target_node_number, counts] <- 1
    if (used == FALSE):
        links[source == source_node_number & target == "None", counts] += 1
      else:
        links[source == source_node_number & target == "None", counts] <- 1

```{r}
left_node_names <- unique(study_usage$Study.Design)
right_node_names <- c("T","MA","None")
all_node_names <- c(left_node_names, right_node_names)

links <- data.frame(source = character(0), target = character(0), count = integer(0))
for (rw in 1:nrow(study_usage)){
  primary <- study_usage$Study.Design[rw]#source
  if (primary %in% left_node_names){
    used <- FALSE #flag for determining secondary usage
    source_node_num <- match(primary, all_node_names)
    # print(primary)
    for (cl in 10:19){
      query_cell <- study_usage[rw,cl]
      if (query_cell %in% right_node_names){
        used <- TRUE
        target_node_num <- match(query_cell, all_node_names)
        #look up if source node and target node already in links
        current_link_combos <- paste(links$source, links$target)#get current combos
        if (paste(source_node_num, target_node_num) %in% current_link_combos){
          node_count <- links[links$source==source_node_num & links$target==target_node_num, "count"]
          # print(paste("final if:", source_node_num, target_node_num, node_count))
          links[links$source==source_node_num & links$target==target_node_num, "count"] <- node_count + 1
        }#if (in link_combos) close
        else{
          new_row <- data.frame("source" = source_node_num,"target" = target_node_num,"count" = 1)
          links <- rbind(links, new_row)
        }#else close
      }#if (query_cell %in% right_node_names close
    }#column for-loop close
    if (used == FALSE){
      #if the primary source wasn't used, we increment the "None" count
      none_index <- match("None", all_node_names)
      current_link_combos <- paste(links$source, links$target)#get current combos
      if (paste(source_node_num, none_index) %in% current_link_combos){
          node_count <- links[links$source==source_node_num & links$target==none_index, "count"]
          # print(paste("'Used' if:", source_node_num, target_node_num, node_count))
          links[links$source==source_node_num & links$target==none_index, "count"] <- node_count + 1
        }#if (in link_combos) close
        else{
          new_row <- data.frame("source" = source_node_num,"target" = none_index,"count" = 1)
          links <- rbind(links, new_row)
        }#else close
    }#if (used == FALSE
  }#if (primary) close
}#row for loop close

#update node names to clarify in plot
all_node_names[all_node_names == "MA"] <- "Meta-analysis"
all_node_names[all_node_names == "T"] <- "Text/tabular summary"
#make node names into dataframe for Sankey input
nodes <- data.frame(nodes = all_node_names)
#Adjust links because JS is 0 indexed
links$source <- links$source - 1
links$target <- links$target - 1

print(links)
```

```{r}

p <- sankeyNetwork(Links = links, Nodes = nodes, Source = "source",
             Target = "target", Value = "count", NodeID = "nodes",
             units = "Studies", fontSize = 20, nodeWidth = 30, 
             margin = list(50,100,500,100), sinksRight = TRUE,
             height = 500, width = 500)

saveNetwork(p, file="output/Study_Usage_Sankey_small.html", selfcontained = TRUE)
p

```

To improve the figure, Dr. Higgins has provided an updated and redesigned input and updated the request for the figure.

```{r}
study_usage <- read.table("study_update.txt", sep="\t", header = T,
                          encoding = "latin1")
head(study_usage)
```

```{r}
rows_use <- nrow(study_usage)-1#because the last line is different data
left_node_names <- unique(study_usage$Reference.Short[1:rows_use])
right_node_names <- c(colnames(study_usage)[3:ncol(study_usage)])
all_node_names <- c(left_node_names, right_node_names)
left_node_groups <- study_usage[nrow(study_usage),3:ncol(study_usage)]
length(all_node_names)
```

#Updated code to include node groupings
```{r}
links <- data.frame(source = character(0), target = character(0), count = integer(0))
node_groups <- c()
# node_groups[length(all_node_names)] <- "None"
for (rw in 1:rows_use){
  primary <- study_usage$Reference.Short[rw]#source
  source_node_num <- match(primary, all_node_names)
  node_groups[source_node_num] <- study_usage$Study.Design[rw]
  target_group <- "None"
  print(paste(rw, primary, study_usage$Study.Design[rw]))
  for (cl in 3:ncol(study_usage)){
    query_cell <- study_usage[rw,cl]
    if (query_cell != "0"){
      target_node_num <- match(colnames(study_usage)[cl], all_node_names)#match returns index
      node_groups[target_node_num] <- study_usage[nrow(study_usage),cl]
      #look up if source node and target node already in links
      current_link_combos <- paste(links$source, links$target)#get current combos
      # print(current_link_combos)
      if (paste(source_node_num, target_node_num) %in% current_link_combos){
        node_count <- links[links$source==source_node_num & links$target==target_node_num, "count"]
        print(paste("final if:", source_node_num, target_node_num, node_count))
        links[links$source==source_node_num & links$target==target_node_num, "count"] <- node_count + 1
      }#if (in link_combos) close
      else{
        new_row <- data.frame("source" = source_node_num,"target" = target_node_num,"count" = 1)
        links <- rbind(links, new_row)
      }#else close
    }#if (query_cell %in% right_node_names close
  }#column for-loop close
  # if (target_group == "None"){
  #   #if the primary source wasn't used, we increment the "None" count
  #   none_index <- match("None", all_node_names)
  #   current_link_combos <- paste(links$source, links$target)#get current combos
  #   if (paste(source_node_num, none_index) %in% current_link_combos){
  #       node_count <- links[links$source==source_node_num & links$target==none_index, "count"]
  #       # print(paste("'Used' if:", source_node_num, target_node_num, node_count))
  #       links[links$source==source_node_num & links$target==none_index, "count"] <- node_count + 1
  #     }#if (in link_combos) close
  #     else{
  #       new_row <- data.frame("source" = source_node_num,"target" = none_index,"count" = 1)
  #       links <- rbind(links, new_row)
  #     }#else close
  # }#if (used == FALSE
}#row for loop close

#make node names into dataframe for Sankey input
nodes <- data.frame(nodes = all_node_names, groups=node_groups)
#Adjust links because JS is 0 indexed
links$source <- links$source - 1
links$target <- links$target - 1

print(links)
```


#New Sankey network:
```{r}

p <- sankeyNetwork(Links = links, Nodes = nodes, Source = "source",
             Target = "target", Value = "count", NodeID = "groups",
             fontSize = 10, nodeWidth = 40,
             sinksRight = TRUE, nodePadding = 3, colourScale = "d3.scaleOrdinal(d3.schemeCategory10)")
             #margin = list(50,100,500,100))
             #, height = 500, width = 500)

saveNetwork(p, file="output/no_none_study_Usage_Sankey.html", selfcontained = TRUE)

# render with js
sankey_rendered <- htmlwidgets::onRender(p,
  'function(el, x) {
    d3.selectAll(".node text")
        .style("fill", "blue");
  }'
)

sankey_rendered
saveNetwork(sankey_rendered, file="output/no_none_blue_study_Usage_Sankey.html",selfcontained = TRUE)

```
#Simple network plot





```{r}
p <- networkD3::simpleNetwork(links)

p
```

```{r}
p <- networkD3::forceNetwork(Links = links, Nodes = nodes, Source = "source",
             Target = "target", Value = "count", NodeID = "nodes", Group = "groups",
             fontSize = 9)

p
```





https://stackoverflow.com/questions/35056733/how-to-capture-html-output-as-png-in-r

http://palomnyk.github.io/Sankey/output/Study_Usage_Sankey.html


